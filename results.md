The output and correctness of each algorithm:
BFS:
- We used breadth-first search to traverse the graph to find the users within a certain number of degrees of connection of a given user. BFS visits a node and then visits all of its neighbors until there are no more nodes to visit. We take in the graph, the user that we want to find the degrees of connection for, and the number of degrees of connection we want to find, and output a map of vectors containing the users within each degree of connections between 1 and the number of degrees input.
- Our test cases checked to see if our map was outputting the correct neighbors within our connections using multiple test graphs. We checked for edge cases by having our graph include cycles and having specific nodes have multiple connections, and made sure our map would still output the right users.

Dijkstras Algorithm:

- We used Dijkstra's algorithm to find the shortest path from one node to another. Dijkstra's algorithm begins at the starting node visits a node and its adjacent neighbors and determines which route is shortest, repeating the process until it reaches the destination node or it is determined that the destination node is not present. 
- Our test cases check to see if the shortest path was properly constructed. We prioritize paths with consecutive numbers: for example, if there were two shortest paths, {1, 2, 3, 4, 5} and {1, 2, 4, 3, 5}, which have the same cost, {1, 2, 3, 4, 5} would be prioritized. If there is no path from one node to another, we expect an empty vector to be output. If two of the same node are input for both the start and end of the path, we expect a vector containing just that node once to be output.